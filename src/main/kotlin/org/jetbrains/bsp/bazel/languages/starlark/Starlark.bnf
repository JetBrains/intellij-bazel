{
  parserClass="org.jetbrains.bsp.bazel.languages.starlark.parser.StarlarkParser"
  parserUtilClass="org.jetbrains.bsp.bazel.languages.starlark.StarlarkParserUtils"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Starlark"
  psiImplClassSuffix="Impl"
  psiPackage="org.jetbrains.bsp.bazel.languages.starlark.psi"
  psiImplPackage="org.jetbrains.bsp.bazel.languages.starlark.psi.impl"

  elementTypeHolderClass="org.jetbrains.bsp.bazel.languages.starlark.StarlarkTypes"
  elementTypeClass="org.jetbrains.bsp.bazel.languages.starlark.StarlarkElementType"
  tokenTypeClass="org.jetbrains.bsp.bazel.languages.starlark.StarlarkTokenType"

  tokens = [
    // keywords
    DEF="def"
    LAMBDA="lambda"

    IF="if"
    ELIF="elif"
    ELSE="else"

    FOR="for"
    IN="in"

    RETURN="return"
    BREAK="break"
    CONTINUE="continue"
    PASS="pass"

    LOAD="load"

    // assign operators
    EQ="="
    PLUS_EQ="+="
    MINUS_EQ="-="
    ASTERISK_EQ="*="
    DIV_EQ="/="
    DIV_INT_EQ="//="
    MODULO_EQ="%="
    AND_EQ="&="
    OR_EQ="|="
    XOR_EQ="^="
    SHIFT_LEFT_EQ="<<="
    SHIFT_RIGHT_EQ=">>="

    // math operators
    PLUS="+"
    MINUS="-"
    ASTERISK="*"
    MODULO="%"
    DIV="/"
    DIV_INT="//"

    // boolean operators
    OR="or"
    AND="and"
    NOT="not"
    IS_EQUAL="=="
    IS_NOT_EQUAL="!="
    LESS_THAN="<"
    GREATER_THAN=">"
    LESS_OR_EQUAL="<="
    GREATER_OR_EQUAL=">="

    // bit operators
    BIT_OR="|"
    BIT_XOR="^"
    BIT_AND="&"
    BIT_SHIFT_LEFT="<<"
    BIT_SHIFT_RIGHT=">>"

    // code organization
    SEMICOLON=";"
    COMMA=","
    COLON=":"
    DOT="."

    LEFT_BRACKET="["
    RIGHT_BRACKET="]"

    LEFT_PAREN="("
    RIGHT_PAREN=")"

    LEFT_CURLY="{"
    RIGHT_CURLY="}"

    // random
    DOUBLE_ASTERISK="**"
    TYLDA="~"

    // complex
    INT="regexp:([1-9][0-9]*)|(0(o|O)[0-7]+)|(0(x|X)[a-fA-F0-9]+)|0"
    FLOAT="regexp:([0-9]+\.[0-9]*((e|E)(\+|\-)?[0-9]+)?)|([0-9]+(e|E)(\+|\-)?[0-9]+)|(\.[0-9]*((e|E)(\+|\-)?[0-9]+)?)"

    IDENTIFIER="regexp:[a-zA-Z_][a-zA-Z0-9_]*"

    // it should be done using some advanced things in the lexer (Starlark.flex), but i dont want to do it now
    STRING="regexp:r?(('''((([^']|\n)*)|(([^']|\n)*'([^']|\n)+)|(([^']|\n)*''([^']|\n)+))*''')|(\"\"\"((([^\"]|\n)*)|(([^\"]|\n)*\"([^\"]|\n)+)|(([^\"]|\n)*\"\"([^\"]|\n)+))*\"\"\")|('([^']|(\\\n))*')|(\"([^\"]|(\\\n))*\"))"
    BYTES="regexp:(b|rb|br)(('''((([^']|\n)*)|(([^']|\n)*'([^']|\n)+)|(([^']|\n)*''([^']|\n)+))*''')|(\"\"\"((([^\"]|\n)*)|(([^\"]|\n)*\"([^\"]|\n)+)|(([^\"]|\n)*\"\"([^\"]|\n)+))*\"\"\")|('([^']|(\\\n))*')|(\"([^\"]|(\\\n))*\"))"

    COMMENT="regexp:#.*"

    WHITE_SPACE="regexp:(\s|\\\n)+"
  ]


  extends(".+Statement") = Statement
  extends(".+Stmt") = Stmt
  extends(".+Expression") = Expression
}

// og syntax: https://github.com/bazelbuild/starlark/blob/master/spec.md#lexical-elements

File ::= Statement*

Statement ::= DefStatement | IfStatement | ForStatement | SimpleStatement

DefStatement    ::= def NNL IDENTIFIER NNL '(' [Parameters [',']] ')' NNL ':' Suite
IfStatement     ::= if NNL Expression NNL ':' Suite (elif NNL Expression  NNL ':' Suite)* [else NNL ':' Suite]
ForStatement    ::= for NNL LoopVariables NNL in NNL ExprStmt NNL ':' Suite
SimpleStatement ::= Stmt (NNL ';' NNL Stmt)* [NNL ';'] (<<newLine>> | <<eof>>)

Stmt ::= ReturnStmt | BreakStmt | ContinueStmt | PassStmt | AssignStmt | ExprStmt | LoadStmt

ReturnStmt   ::= return [NNL ExprStmt] (<<newLine>> | <<eof>>)
BreakStmt    ::= break
ContinueStmt ::= continue
PassStmt     ::= pass
AssignStmt   ::= ExprStmt NNL AssignOperator NNL ExprStmt
ExprStmt     ::= Expression (NNL ',' Expression)*
LoadStmt     ::= load NNL '(' STRING (',' [IDENTIFIER '='] STRING)* [','] ')'

Expression ::= IfExpression | BinaryExpression | UnaryExpression | PrimaryExpression | LambdaExpression
IfLastExpr ::= BinaryExpression | UnaryExpression | PrimaryExpression | LambdaExpression | IfExpression

IfExpression      ::= Expression NNL if NNL Expression NNL else NNL Expression
UnaryExpression   ::= UnaryOperator NNL Expression
BinaryExpression  ::= Expression (NNL BinaryOperator NNL Expression)+
PrimaryExpression ::= Operand Suffix*
LambdaExpression  ::= lambda NNL [Parameters] NNL ':' NNL Expression


private Suite ::= <<checkIfIndentIncreasesAndSaveIt>> (<<checkIndent>> Statement)+ <<finishBlock>>
                | NNL SimpleStatement

LoopVariables ::= PrimaryExpression (NNL ',' PrimaryExpression)*

Operand ::= IDENTIFIER | INT | FLOAT | STRING | BYTES
          | ListComp | ListExpr | DictComp | DictExpr
          | '(' [ExprStmt [',']] ')'

private Suffix ::= NNL (DotSuffix | CallSuffix | SliceSuffix)
DotSuffix      ::= '.' NNL IDENTIFIER
SliceSuffix    ::= '[' [ExprStmt] ':' [Expression] [':' [Expression]] ']' | '[' ExprStmt ']'
CallSuffix     ::= '(' [Arguments [',']] ')'

Parameters  ::= Parameter (',' Parameter)*
Parameter   ::= IDENTIFIER '=' Expression | IDENTIFIER | '*' IDENTIFIER | '**' IDENTIFIER

Arguments   ::= Argument (',' Argument)*
Argument    ::= IDENTIFIER '=' Expression | '*' Expression | '**' Expression | Expression

ListExpr    ::= '[' [ExprStmt [',']] ']'
ListComp    ::= '[' IfLastExpr CompClause* ']'

DictExpr    ::= '{' [Entries [',']] '}'
DictComp    ::= '{' IfLastEntry CompClause* '}'

Entries     ::= Entry (',' Entry)*
Entry       ::= Expression NNL ':' NNL Expression
IfLastEntry   ::= Expression NNL ':' NNL IfLastExpr

CompClause  ::= (for NNL LoopVariables NNL in | if) NNL IfLastExpr

UnaryOperator ::= '+' | '-' | '~' | 'not'

AssignOperator ::= '=' | '+=' | '-=' | '*=' | '/=' | '//=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>='

BinaryOperator ::= '==' | '!=' | '<' | '>' | '<=' | '>='
                 | '*' | '%' | '/' | '//' | '+' | '-'
                 | '|' | '^' | '&' | '<<' | '>>'
                 | in | not in
                 | or | and
                 
private NNL ::= !<<newLine>>